% vim:syntax=tex

\begin{comment}
Points to make:

- Why FLTs matter
- What the problem is
- What our solution is
- How we evaluate it
- Contrib
- Organization
\end{comment}

Software developers are often confronted with maintenance tasks that involve navigation of repositories that preserve vast amounts of project history.
Navigating these software repositories can be a time-consuming task, because their organization can be difficult to understand.
A software developer who is tasked with changing a large software system spends effort on program comprehension activities to gain the knowledge needed to make the change~\cite{Corbi:1989}.
Fortunately, topic models such as
latent semantic indexing (LSI)~\cite{Deerwester-etal:1990} and
latent Dirichlet allocation (LDA)~\cite{Blei-etal:2003}
can help developers to navigate and understand software repositories
by discovering topics (word distributions) that reveal the thematic structure
of the data~\cite{Linstead-etal:2007,Thomas-etal:2011,Hindle-etal:2012}.

Typical topic-model-based FLTs construct models from corpora of text extracted from a source code snapshot.
That is, a topic model is often trained on a corpus that contains documents that
represent source code entities, such as methods or classes, from a particular version of the software.
Keeping such a model up-to-date is expensive,
because the frequency and scope of source code changes necessitate retraining the model on the updated corpus.
In this paper we propose a fresh take on topic-modeling-based FLTs
by leveraging online topic models and mining software repositories
to construct topic models that can be used in real-time without needing retraining.
Previous work in Corley et al.~\cite{Corley-etal:2014} has shown that
topic models trained on changesets produce topics which have
comparable topic distinctness scores~\cite{Thomas-etal:2011} as
topic models trained on snapshots.
We expand this work to demonstrate the effectiveness of changeset topic modeling for feature location.

Online topic models are topic models which do not need to know
the entire input corpus prior to training~\cite{Hoffman-etal:2010,Radim:2011}
That is, online topic models can be instantiated once and incrementally updated over time.
Additionally, training the model and infering how documents relate with the model
can be intermixed.
Moreover, a version control repository keeps a history of source code documents as they change over time.
These changes are represented as changesets,
which provide concise views of the differences between two versions of the same document.
By training a topic model on changesets, we can enable practical topic
modeling for automating software maintenance tasks such as feature
location.

In this paper we propose an approach to topic modeling changesets for feature location
and report on an empirical study in which we investigate the feasibility of this approach.
We define two topic-model-based FLTs on both LSI and LDA using changesets.
We combine two benchmarks totaling over 1200 defects and features from fourteen open source Java projects.
Our results show that not only is our changeset approach feasible and practical,
but in some cases out-performs current snapshot approaches.


This paper makes the following contributions:

\begin{itemize}
    \item An approach to topic modeling changesets for feature location
    \item An approach to evaluating a feature location technique temporally
    \item A tool that implements the approaches
    \item A case study of the of the two approaches
    \item An updated dataset of systems used in this study
    \item Towards increasing open science principles in software engineering,
        the complete source code history and data for replication of this study
\end{itemize}

The remainder of the paper is organized as follows.
We first review background and related work (\S\ref{sec:related})
before introducing our new feature location technique (\S\ref{sec:changeset}).
We next discuss our case study (\S\ref{sec:study}), which spans fourteen open source Java projects. % 19 total w/ all versions
We then conclude (\S\ref{sec:conclusion}).

